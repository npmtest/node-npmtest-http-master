{"/home/travis/build/npmtest/node-npmtest-http-master/test.js":"/* istanbul instrument in package npmtest_http_master */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-http-master/lib.npmtest_http_master.js":"/* istanbul instrument in package npmtest_http_master */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_http_master = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_http_master = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-http-master/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-http-master && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_http_master */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_http_master\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_http_master.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_http_master.rollup.js'] =\n            local.assetsDict['/assets.npmtest_http_master.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_http_master.__dirname + '/lib.npmtest_http_master.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-http-master/node_modules/http-master/src/HttpMaster.js":"var async = require('async');\n\nvar EventEmitter = require('eventemitter3');\nvar path = require('path');\nvar CertScanner = require('./certScanner');\nvar extend = require('extend');\nvar loadKeysForContext = require('./keyContextLoader');\n\nvar token = require('crypto').randomBytes(64).toString('hex');\nvar JSONfn = require('jsonfn').JSONfn;\n\n// TODO: Windows support?\nfunction exitIfEACCES(err) {\n  if (err && err.syscall === 'bind' && err.code === 'EACCES') {\n    this.logError(\"Unable to bind to port, exiting! Hopefully we will be restarted with privileges to bind the port.\");\n    process.exit(1);\n  }\n}\n\nfunction HttpMaster() {\n  var workers = this.workers = [];\n  this.tlsSessionStore = {};\n\n  // hacky way to ensure that our cluster is a locally loaded one\n  // use this until https://github.com/joyent/node/pull/3367 is merged\n  var oldCluster = require.cache[require.resolve('cluster')];\n  delete require.cache[require.resolve('cluster')];\n  var cluster = this.cluster = require('cluster');\n  require.cache[require.resolve('cluster')] = oldCluster;\n\n  this.cluster.setupMaster({\n    exec: path.join(__dirname, 'worker.js'),\n    args: []\n  });\n\n  this.autoRestartWorkers = true;\n\n  var self = this;\n  cluster.on('exit', function(worker, code, signal) {\n    if (!self.autoRestartWorkers) {\n      return;\n    }\n    self.logError(\"Worker \" + worker.id + \" failed with code \" + code + \"/\" + signal + \" ... starting replacement\");\n    workers[worker.id - 1] = undefined;\n    var newWorker = initWorker.call(self, function() {\n      self.logNotice(\"Worker \" + newWorker.id + \" started in place of worker \" + worker.id);\n      workers[newWorker.id - 1] = newWorker;\n    });\n  });\n\n}\n\nfunction initWorker(cb) {\n  var self = this;\n  var worker = this.cluster.fork();\n  worker.sendMessage = function(type, data) {\n    worker.send(JSONfn.stringify({\n      type: type,\n      data: data\n    }));\n  };\n\n  worker.sendMessage('start', {\n    config: this.config,\n    token: this.token\n  });\n  worker.emitter = new EventEmitter();\n  worker.on(\"message\", function(msg) {\n    msg = JSON.parse(msg);\n    process.emit('msg:' + msg.type, msg.data, worker);\n    worker.emit('msg:' + msg.type, msg.data);\n    worker.emit('msg', {\n      type: msg.type,\n      data: msg.data\n    });\n  });\n\n  worker.once('msg:started', function(err) {\n    cb(err);\n  });\n  worker.on('msg:exception', function(err) {\n    exitIfEACCES.call(self, err);\n  });\n\n  worker.on('msg:tlsSession:set', function(msg) {\n    self.tlsSessionStore[msg.id] = {\n      data: msg.data,\n      created: new Date()\n    };\n  });\n\n  worker.on('msg:tlsSession:get', function(id) {\n    var data = '';\n    if (self.tlsSessionStore[id]) {\n      data = self.tlsSessionStore[id].data;\n    }\n    worker.sendMessage('session:' + id, data);\n  });\n\n  return worker;\n}\n\nHttpMaster.prototype = Object.create(EventEmitter.prototype);\n\nHttpMaster.prototype.logNotice = function(msg) {\n  this.emit('logNotice', msg);\n};\n\nHttpMaster.prototype.logError = function(msg) {\n  this.emit('logError', msg);\n};\n\nfunction preprocessPortConfig(config, cb) {\n  var self = this;\n  if (config.ssl) {\n\n    var loadsToDo = [];\n    loadsToDo.push(config.ssl);\n    if (config.ssl.SNI) {\n      for (var key in config.ssl.SNI)\n        loadsToDo.push(config.ssl.SNI[key]);\n    }\n    async.each(loadsToDo, loadKeysForContext, function(err) {\n      if (!config.ssl.certDir)\n        return cb(config);\n\n      var certScanner = new CertScanner(config.ssl.certDir, {\n        read: true,\n        onlyWithKey: true\n      });\n      certScanner.on('notice', function(msg) {\n        self.logNotice(msg);\n      });\n      self.logNotice(\"Scanning for certificates in directory: \" + config.ssl.certDir);\n      certScanner.scan(function(err, SNIconfig) {\n        if (err) {\n          self.logError(\"Error processing certDir: \" + err.toString());\n          return cb(config);\n        }\n        //sslConfig = {SNI: sslConfig};\n        if (config.ssl.primaryDomain) {\n          config.ssl = extend(true, {}, config.ssl, SNIconfig[config.ssl.primaryDomain]);\n        } else {\n          var firstKey = Object.keys(SNIconfig)[0];\n          if (firstKey) {\n            self.logNotice(\"Primary domain not set, assuming: \" + firstKey);\n            config.ssl = extend(true, {}, config.ssl, SNIconfig[firstKey]);\n          }\n        }\n        config.ssl = extend(true, {}, config.ssl, {\n          SNI: SNIconfig\n        });\n        certScanner.removeAllListeners();\n        cb(config);\n      });\n\n    });\n\n  } else {\n    cb(config);\n  }\n}\n\nfunction preprocessConfig(config, cb) {\n  var self = this;\n  async.each(Object.keys(config.ports || {}), function(portKey, cb) {\n    preprocessPortConfig.call(self, config.ports[portKey], function(portConfig) {\n      config.ports[portKey] = portConfig;\n      cb();\n    });\n  }, function() {\n\n    if (config.debug === 'config')\n      console.log(require('util').inspect(config, false, null));\n    cb(config);\n  });\n}\n\n\nfunction setupDi() {\n  var self = this;\n  var di = this.di = new DI();\n  di.onMissing = function(name) {\n    var m;\n    if ((m = name.match(/(.+)Service$/))) {\n      name = m[1];\n      try {\n        this.bindType(name + 'Service', require(path.join(__dirname, '..', 'modules', 'services', name)));\n      } catch (err) {\n        console.log(err && err.message);\n        return;\n      }\n      self.emit('loadService', name);\n      return this.resolve(name + 'Service');\n    }\n  };\n\n  di.bindInstance('di', di);\n  di.bindInstance('master', this);\n  di.bindInstance('worker', null);\n  di.bindInstance('events', process);\n\n  di.bindResolver('config', function() {\n    return self.config;\n  });\n  var config = self.config;\n\n  config.modules = config.modules || {};\n\n  Object.keys(config.modules).forEach(function(moduleName) {\n    if (!config.modules[moduleName])\n      return;\n    var di = self.di.makeChild();\n    di.bindInstance('di', di);\n    di.bindInstance('moduleConfig', config.modules[moduleName]);\n    try {\n      di.resolve(require(path.join(__dirname, '..', 'modules', moduleName)));\n    } catch (err) {\n      console.error(\"Error loading module:\", moduleName, err.stack);\n    }\n  });\n}\n\nHttpMaster.prototype.reload = function(config, reloadDone) {\n  var self = this;\n  this.emit('reload');\n\n  function actualReload(config) {\n    self.config = config;\n    var workers = self.workers;\n\n    setupDi.call(self);\n\n    if ((config.workerCount || 0) !== self.workerCount) {\n      //self.logError(\"Different workerCount, exiting! Hopefully we will be restarted and run with new workerCount\");\n      var err = new Error('Got different workerCount than initialized with');\n      self.emit('error', err);\n      self.emit('restartIfPossible'); // http-master may exit\n      if (reloadDone)\n        reloadDone(err);\n      return;\n    }\n\n    if (self.singleWorker) {\n      self.singleWorker.loadConfig(config, function(err) {\n        exitIfEACCES.call(self, err);\n        if (!err)\n          self.emit('allWorkersReloaded');\n        else\n          self.emit('error', err);\n\n        self.emit('allWorkersReloaded');\n        if (reloadDone)\n          reloadDone(err);\n      });\n    } else {\n      async.parallel(workers.filter(function(worker) {\n          return !!worker;\n        }) // dead workers leave undefined keys\n        .map(function(worker) {\n          return function(asyncCallback) {\n            worker.once('msg:unbindFinished', function() {\n\n              worker.once('msg:started', function() {\n                asyncCallback();\n              });\n              worker.sendMessage('reload', config);\n            });\n            worker.sendMessage('unbind');\n          };\n        }),\n        function(err) {\n          if (!err)\n            self.emit('allWorkersReloaded');\n          else\n            self.emit('error', err);\n          if (reloadDone)\n            reloadDone(err);\n        });\n    }\n  }\n\n  preprocessConfig.call(this, config, actualReload);\n};\n\nvar DI = require('./di');\n\nHttpMaster.prototype.init = function(config, initDone) {\n  var self = this;\n  var workers = this.workers;\n\n  function actualInit(config) {\n    self.config = config;\n\n    setupDi.call(self);\n\n    self.workerCount = config.workerCount || 0;\n    if (self.workerCount === 0) {\n      var singleWorker = self.singleWorker = new(require('./HttpMasterWorker'))();\n\n      singleWorker.sendMessage = function(type, data) {\n        process.emit('msg:' + type, data, singleWorker);\n        process.emit('msg', {\n          type: type,\n          data: data\n        }, singleWorker);\n      };\n      singleWorker.on('logNotice', self.logNotice.bind(self));\n      singleWorker.on('logError', self.logError.bind(self));\n      singleWorker.on('loadService', function(name) {\n        self.di.resolve(name + 'Service');\n      });\n      self.singleWorker.loadConfig(config, function(err) {\n        if (err) {\n          return initDone(err);\n        }\n        self.emit('allWorkersStarted');\n\n        //runModules(\"allWorkersStarted\", config);\n        if (initDone) {\n          initDone();\n        }\n      });\n    } else {\n      while (!token) {} // busy wait in case we have not got it yet..\n      self.token = token;\n\n      async.times((config.workerCount), function(n, next) {\n        var worker = initWorker.call(self, function(err) {\n          next(err);\n        });\n        worker.on('msg:logNotice', self.logNotice.bind(self));\n        worker.on('msg:logError', self.logError.bind(self));\n        worker.on('msg:masterLoadService', function(name) {\n          self.di.resolve(name + 'Service');\n        });\n        workers.push(worker);\n      }, function(err) {\n        self.emit('allWorkersStarted');\n\n        if (initDone)\n          initDone(err);\n      });\n    }\n  }\n  preprocessConfig.call(this, config, actualInit);\n};\n\nmodule.exports = HttpMaster;\nmodule.exports.CertScanner = CertScanner;\nmodule.exports.regexpHelper = require('./regexpHelper');\n","/home/travis/build/npmtest/node-npmtest-http-master/node_modules/http-master/src/certScanner.js":"'use strict';\n\nvar x509 = require('x509.js');\nvar fs = require('fs');\nvar async = require('async');\nvar path = require('path');\nvar moment = require('moment');\nvar util = require('util');\n\nvar EventEmitter = require('eventemitter3');\n\n// TODO: rework into promises\nclass CertScanner extends EventEmitter {\n  constructor(sslDirectory, options) {\n    super();\n    \n    this.options = options;\n    \n    options = options || {};\n\n    if(!sslDirectory) {\n      throw new Error('sslDirectory as first argument is mandatory');\n    }\n\n    this.sslDirectory = sslDirectory;\n    if (!sslDirectory.match(/\\/$/)) {\n      this.sslDirectory += '/';\n    }\n\n    this.readPart = async.memoize(function(file, maxRead, cb) {\n      fs.open(file, 'r', function(err, fd) {\n        if(err) return cb(err);\n        var buf = new Buffer(maxRead);\n        fs.read(fd, buf, 0, maxRead, null, function(err, bytesRead, buffer) {\n          fs.close(fd);\n          if(bytesRead < maxRead)\n            return cb(err, buffer.slice(0, bytesRead).toString('utf8'));\n          return cb(err, buffer.toString('utf8'));\n        });\n      });\n    });\n\n    var beginCertToken = '-----BEGIN CERTIFICATE-----';\n    var endCertToken = '-----END CERTIFICATE-----';\n    this.getCaCertsFromFile = function(certPath, cb) {\n      // TODO: This can possibly be replaced with some regexp.\n      this.readPart(certPath, 4*65536, function(err, certFileContent) {\n        if(err) return cb(err);\n\n        var possibleCerts = certFileContent.split(beginCertToken);\n        var certs = [];\n        var rawCerts = [];\n        possibleCerts.forEach(function(cert) {\n          var endTokenIndex = cert.indexOf(endCertToken);\n          if (endTokenIndex === -1) {\n            return null;\n          }\n          var rawCert = cert.substring(0, endTokenIndex);\n          var parsedCert = beginCertToken + rawCert + endCertToken + '\\n';\n          try {\n            certs.push(x509.parseCert(parsedCert));\n            rawCerts.push(parsedCert);\n          } catch(err) {\n\n          }\n        });\n        cb(null, certs, rawCerts);\n      });\n    };\n    \n    this.getCaFor = async.memoize((certPath, cb) => {\n      this.readPart(certPath, 65636, (err, rawCert) => {\n        if(err) return cb(err);\n\n        var parsedCert;\n        try {\n          parsedCert = x509.parseCert(rawCert);\n        } catch(err) {\n          return cb(err);\n        }\n        var caResults = [];\n        var caRawResults = [];\n        let processDirectory = (dirName, cb) => {\n          fs.readdir(dirName, (err, files) => {\n\n            if(err) return cb(err);\n\n            async.filter(files, (certFile, cb) => {\n              var certPath = path.join(dirName, certFile);\n\n              fs.stat(certPath, (err, statData) => {\n                if(statData.isDirectory()) {\n                  return processDirectory(certPath, () => {\n                    cb(null, false); // is a directory\n                  });\n                }\n\n                this.getCaCertsFromFile(certPath, (err, certs, rawCerts) => {\n                  if(err) return cb(null, false);\n\n                  if (this.isDomainCert(certs)) {\n                    return cb(null, false);\n                  }\n                  var matchingCa = certs.filter((cert, i) => {\n                    var res = this.caMatches(cert, parsedCert);\n\n                    if(res) {\n                      caRawResults.push(rawCerts[i]);\n                    }\n                    return res;\n                  });\n                  return cb(null, matchingCa.length);\n                });\n              });\n            }, function(err, ca) {\n              caResults = ca.map(fileName => {\n                return path.join(dirName, fileName);\n              }).concat(caResults);\n\n              cb(null);\n            });\n          });\n        }\n        processDirectory(this.sslDirectory, err => {\n          if(err) return cb(err);\n\n          function noArrayIfOne(arr) {\n            return (arr.length === 1) ? arr[0] : arr;\n          }\n\n          if(caResults.length) {\n            cb(null, noArrayIfOne(caResults), noArrayIfOne(caRawResults));\n          }\n          else {\n            cb(null);\n          }\n        });\n      });\n    });\n  }\n  \n  scan(cb) {\n    var outputConfig = {};\n\n    var keys = {};\n    var certs = {};\n\n    let options = this.options;\n\n    let processDirectory = (dirName, cb) => {\n      fs.readdir(dirName, (err, files) => {\n        if(err) return cb(err);\n\n        async.each(files, (certFile, cb) => {\n          var certPath = path.join(dirName, certFile);\n\n          fs.stat(certPath, (err, statData) => {\n            if(err) return cb(err);\n\n            if(statData.isDirectory())\n              return processDirectory(certPath, err => {\n                if(err && err.code === 'EACCES') {\n                  this.emit('notice', path.join(dirName, certPath) + ': directory is not accessible');\n                  return cb(null);\n                }\n                cb(err);\n              });\n\n            this.getCertOrPem(certPath, (err, cert, pem, rawCert) => {\n              if(pem) {\n                keys[pem.publicModulus] = options.read ? rawCert : certPath;\n                return cb();\n              }\n              if(err)  {\n                if(err.code === 'EACCES') {\n                  this.emit('notice', path.join(dirName, certPath) + ': file is not readable');\n                  return cb(null);\n                }\n                if(err.toString().match(/Certificate data larger than/))\n                  return cb(null);\n                if(err.toString().match(/Unable to parse/))\n                  return cb(null);\n                if(err.toString().match(/Certificate argument provided, but left blank/))\n                  return cb(null);\n                return cb(err);\n              }\n              if(!err && !cert && !pem) {\n                return cb();\n              }\n\n\n              if(!options.acceptInvalidDates) {\n                var notBeforeMoment = moment(new Date(cert.notBefore));\n                var notAfterMoment = moment(new Date(cert.notAfter));\n                var nowMoment = moment();\n                if(notBeforeMoment.diff(nowMoment) < 0) { // valid\n                  if(notAfterMoment.diff(nowMoment) > 0) { // valid\n                    if(notAfterMoment.diff(nowMoment, 'd') < 90) {\n                      var daysValid = notAfterMoment.diff(nowMoment, 'd').toString();\n                      var hoursValid = notAfterMoment.diff(nowMoment, 'h') - daysValid*24;\n                      this.emit('notice', path.join(dirName, certPath) + ': valid only for ' + daysValid + ' days ' + hoursValid + ' hours');\n                    }\n                  }\n                  else { //expired\n                    this.emit('notice', path.join(dirName, certPath) + ': expired ' + (-notAfterMoment.diff(nowMoment, 'd')).toString() + ' days ago');\n                    return cb();\n                  }\n                }\n                else { // not yet valid\n                  this.emit('notice', path.join(dirName, certPath) + ': not yet valid for ' + (notBeforeMoment.diff(nowMoment, 'd')).toString() + ' days');\n                  return cb();\n                }\n              }\n\n              \n\n              var altNames = cert.altNames;\n\n              var keyForCert = options.read ? rawCert : certPath;\n              certs[keyForCert] = cert.publicModulus;\n\n              async.each(altNames, (domain, cb) => {\n                outputConfig[domain] = {};\n                outputConfig[domain].cert = options.read ? rawCert : certPath;\n\n                this.getCaFor(certPath, (err, ca, caRaw) => {\n                  if (ca) {\n                    outputConfig[domain].ca = options.read ? caRaw : ca;\n                  }\n                  cb(err);\n                });\n              }, cb);\n\n            });\n\n\n          });\n        }, function(err) {\n          cb(err);\n        });\n      });\n    }\n    processDirectory(this.sslDirectory, function(err) {\n\n      Object.keys(outputConfig).forEach(function(domain) {\n        var key = keys[certs[outputConfig[domain].cert]];\n\n\n        // flatten CA reuslts array by removing duplicates\n        var ca = outputConfig[domain].ca;\n        if(ca && ca instanceof Array) {\n          ca = ca.filter(function(elem, pos) {\n            return ca.indexOf(elem) == pos;\n          });\n          if(ca.length === 1)\n            outputConfig[domain].ca = ca[0];\n          else\n            outputConfig[domain].ca = ca;\n        }\n\n\n        if(key) {\n          outputConfig[domain].key = key;\n        }\n        else if(options.onlyWithKey) {\n          delete outputConfig[domain];\n        }\n      });\n\n      cb(err, outputConfig);\n    });\n  }\n  \n  getCertOrPem(certPath, cb) {\n    this.readPart(certPath, 65536, function(err, rawCert) {\n      if(err) return cb(err);\n      try {\n        var cert = x509.parseCert(rawCert);\n        return cb(null, cert, null, rawCert);\n        \n      } catch(err) {\n        try {\n          var pem = x509.parseKey(rawCert);\n\n          return cb(null, null, pem, rawCert);\n        } catch(err2) {\n\n        }\n        cb(err);\n      }\n    });\n  }\n\n  isDomainCert(certs) {\n    return certs.some(function(cert) {\n      return cert.altNames.length > 0;\n    });\n  }\n\n  caMatches(caCert, issuedCertificatedbyCA) {\n    let subject = caCert.subject;\n    let expectedIssuer = issuedCertificatedbyCA.issuer;\n    let status =\n     expectedIssuer.countryName === subject.countryName\n        && expectedIssuer.organizationName === subject.organizationName\n        && expectedIssuer.organizationalUnitName === subject.organizationalUnitName\n        && expectedIssuer.commonName === subject.commonName\n       && caCert.publicModulo === issuedCertificatedbyCA.publicModulo\n       && caCert.publicExponent === issuedCertificatedbyCA.publicExponent\n        ;\n\n    return status;\n  }\n}\n\nmodule.exports = CertScanner;\n","/home/travis/build/npmtest/node-npmtest-http-master/node_modules/http-master/src/keyContextLoader.js":"var async = require('async');\nvar fs = require('fs');\n\nfunction normalizeCert(cert) {\n  cert = cert.toString('utf8');\n  if (!cert.match(/\\n$/g)) {\n    return cert + \"\\n\";\n  }\n  return cert;\n}\n\nfunction loadForCaBundle(context, callback) {\n  var chain = normalizeCert(fs.readFileSync(context.ca, 'utf8'));\n  chain = chain.split(\"\\n\");\n  context.ca = [];\n  var cert = [];\n  chain.forEach(function(line) {\n    if (line.length == 0)\n      return;\n    cert.push(line);\n    if (line.match(/-END CERTIFICATE-/)) {\n      context.ca.push(cert.join(\"\\n\") + \"\\n\");\n      cert = [];\n    }\n  });\n  callback();\n}\n\nfunction loadForCaArray(context, callback) {\n  var caArray = context.ca;\n\n  if(context.ca.length) {\n    async.parallel(context.ca.map(function(elem, i) {\n      return function(cb) {\n        fs.readFile(caArray[i], 'utf8', function(err, data) {\n          context.ca[i] = normalizeCert(data);\n          cb(err);\n        });\n      }\n    }), callback);\n  }\n  else {\n    callback();\n  }\n}\n\nfunction loadKeysForContext(context, callback) {\n\n  async.each(Object.keys(context), function(key, keyFinished) {\n    // If CA certs are specified, load those too.\n    if (key === \"ca\") {\n      if (typeof context.ca === 'object') {\n        loadForCaArray(context, keyFinished);\n      } else {\n        loadForCaBundle(context, keyFinished);\n      }\n    } else if (key == \"cert\" || key == \"key\") {\n\n      fs.readFile(context[key], function(err, data) {\n        if(err) return keyFinished(err);\n        context[key] = normalizeCert(data.toString('utf8'));\n        keyFinished();\n      });\n    } else\n      keyFinished();\n  }, function(err) {\n    callback(err);\n  });\n}\n\nmodule.exports = loadKeysForContext;","/home/travis/build/npmtest/node-npmtest-http-master/node_modules/http-master/src/di.js":"'use strict';\nvar extend = require('extend');\nvar assert = require('assert');\n\nvar functionRegex = /function\\s*([^()]*)\\s*\\(([^)]*)/;\n// get function arguments as array\nfunction functionParameters(f) {\n  assert(typeof f === 'function');\n  var matches = functionRegex.exec(f.toString());\n  if(!matches || !matches[2].length) {\n    return [];\n  }\n  return matches[2].split(/[,\\s]+/).filter(function(str) {\n    return str.length;\n  });\n}\nfunction functionName(f) {\n  assert(typeof f === 'function');\n  var matches = functionRegex.exec(f.toString());\n  if(!matches || !matches[1].length) {\n    return null;\n  }\n  return matches[1];\n}\n\n// call new operator with array of arguments\nfunction construct(constructor, args) {\n  function F() {\n    return constructor.apply(this, args);\n  }\n  F.prototype = constructor.prototype;\n  return new F();\n}\n\nfunction DI() {\n  this.mapping = {};\n  this.parent = null;\n  this.onMissing = function(name) {\n  }\n}\n\nfunction stringToCamelCase(str) {\n  return str.replace(/^\\w/g, function(txt) {\n    return txt.charAt(0).toLowerCase();\n  });\n}\n\nfunction bindTypeGeneric(doCache, name, type) {\n  // implicit name from function name\n  if(typeof name === 'function') {\n    type = name;\n    var constructorName = functionName(type);\n    if(!constructorName) {\n      throw new Error('Unable to resolve name from function');\n    }\n    // implicitly bind function MyType {} to\n    // MyType - type instance\n    // myType - instance\n    var instanceName = stringToCamelCase(constructorName);\n    if(instanceName !== constructorName) {\n      try {\n        this.bindInstance(constructorName, type);\n      } catch(err) {\n        // ignore error since we are already doing this implicitly\n      }\n    }\n    name = instanceName;\n  }\n  if(this.mapping[name]) {\n    throw new Error('\\'' + name + '\\' already bound');\n  }\n\n  var self = this;\n  var mapping = {\n    // this.cache is saved in mapping\n    // 'this' is mapping\n    resolve: function(overrides) { \n      var result = this.cache;\n      if(!result) {\n        result = construct(type, functionParameters(type).map(function(paramName) {\n          return self.resolve(paramName, overrides);\n        }));\n      }\n      if(doCache) {\n        this.cache = result;\n      }\n      return result;\n    }\n  };\n  this.mapping[name] = mapping;\n}\n\nDI.prototype.bindInstance = function(name, instance) {\n  if(this.mapping[name]) {\n    throw new Error('\\'' + name + '\\' already bound');\n  }\n  this.mapping[name] = {\n    resolve: function() {\n      return instance;\n    }\n  };\n};\n\nDI.prototype.bindResolver = function(name, resolver) {\n  if(this.mapping[name]) {\n    throw new Error('\\'' + name + '\\' already bound');\n  }\n  this.mapping[name] = {\n    resolve: resolver\n  };\n}\n\nDI.prototype.bindType = function(name, type) {\n  return bindTypeGeneric.call(this, true, name, type);\n};\n\nDI.prototype.bindTransientType = function(name, type) {\n  return bindTypeGeneric.call(this, false, name, type);\n};\n\nDI.prototype.resolve = function(obj, overrides) {\n  var dependencyMap = extend({}, this.mapping, overrides);\n  var args;\n  var resolved;\n\n  if(typeof obj === 'function') {\n    args = functionParameters(obj);\n    resolved = construct(obj, args.map(this.resolve.bind(this)));\n  } else if(typeof obj === 'string') {\n    if(dependencyMap[obj]) {\n      if(dependencyMap[obj].resolve) {\n        resolved = dependencyMap[obj].resolve(overrides);\n      } else {\n        resolved = dependencyMap[obj];\n      }\n    }\n  } else {\n    throw new Error('Unknown type to resolve');\n  }\n\n  if(typeof resolved ==='undefined' && this.onMissing) {\n    resolved = this.onMissing(obj);\n  }\n\n  if(typeof resolved === 'undefined' && this.parent) { // search in parent if not found\n    resolved = this.parent.resolve(obj, overrides);\n  }\n\n  if(typeof resolved === 'undefined' && !dependencyMap[obj]) {\n    throw new Error('No recipe to resolve \\'' + obj + '\\'');\n  }\n\n  return resolved;\n}\n\nDI.prototype.clone = function() {\n  var cloned = new DI();\n  cloned.mapping = extend({}, this.mapping);\n  cloned.parent = this.parent;\n  cloned.onMissing = this.onMissing;\n  return cloned;\n};\n\nDI.prototype.makeChild = function() {\n  var child = construct(DI, Array.prototype.slice.apply(arguments));\n  child.parent = this;\n  return child;\n};\n\nmodule.exports = DI;\n","/home/travis/build/npmtest/node-npmtest-http-master/node_modules/http-master/src/regexpHelper.js":"function processMatch(target, m) {\n  var keyWithOffset;\n  if (m) {\n    for(var key in m) {\n      var replaceFrom = key;\n      if(!isNaN(key)) {\n        replaceFrom = parseInt(key)+1;\n      }\n      var replaceValue = m[key];\n      target = target.replace(\"[\" + replaceFrom + \"]\", replaceValue?replaceValue:\"\");\n    }\n  }\n  return target;\n}\n\nmodule.exports = function(href, match) {\n  var pathMatchOffset = 0;\n  return processMatch(href, match);\n}","/home/travis/build/npmtest/node-npmtest-http-master/node_modules/http-master/migrateV1Config.js":"var yaml = require('js-yaml');\n\n/* This is sample preprocessor, modify it for your needs */\nmodule.exports = function(argv, data, cb) {\n\n  var oldWarn = console.warn;\n  console.warn = function() {};\n\n  var config = yaml.safeLoad(data);\n\n\n  if(config.logging) {\n    if(config.logging.appLog) {\n      config.modules = config.modules || {};\n      config.modules.appLog = config.logging.appLog;\n    }\n    if(config.logging.accessLog) {\n      config.middleware = config.middleware || [];\n      config.middleware.push(\n        'log -> ' + config.logging.accessLog\n      );\n    }\n    delete config.logging;\n  }\n  config.ports = config.ports || {};\n  if(config.gzip) {\n    config.middleware = config.middleware || [];\n    config.middleware.push(\n      'gzip -> 9'\n    );\n  }\n  delete config.gzip;\n  Object.keys(config.ports).forEach(function(port) {\n    var portConfig = config.ports[port];\n    if(portConfig.gzip) {\n\tconfig.ports[port] = ['gzip -> 9', portConfig];\n    }\n    delete portConfig.gzip;\n    \n    portConfig.router = portConfig.router || {};\n\n    function migrateEntries(name) {\n      Object.keys(portConfig[name]).forEach(function(key) {\n        var portConfigEntry = portConfig[name][key];\n        if(name !== 'proxy')\n          portConfigEntry = name + \" -> \" + portConfigEntry.toString();\n        if(name === 'proxy' && portConfigEntry.auth) {\n    \t    portConfigEntry = ['auth -> ' + portConfigEntry.auth, portConfigEntry.target];\n        }\n        portConfig.router[key] = portConfigEntry;\n      });\n    }\n    delete portConfig.silent;\n    if(portConfig.reject) {\n      migrateEntries('reject');\n      delete portConfig.reject;\n    }\n    if(portConfig.static) {\n     migrateEntries('static');\n     delete portConfig.static;\n    }\n    if(portConfig.redirect) {\n     migrateEntries('redirect');\n     delete portConfig.redirect;\n    }\n    if(portConfig.proxy) {\n      migrateEntries('proxy');\n      delete portConfig.proxy;\n    }\n    if(portConfig.ssl) { // make sure ssl is appended at the end\n      var sslConfig = portConfig.ssl;\n      delete portConfig.ssl;\n      portConfig.ssl = sslConfig;\n    }\n\n  });\n  console.log(\"Migrated old config!\");\n\tcb(null, config);\n};","/home/travis/build/npmtest/node-npmtest-http-master/node_modules/http-master/modules/appLog.js":"var util = require('util');\nvar fs = require('fs');\nvar util = require('util');\n\nmodule.exports = function Logging(logFileService, master, moduleConfig) {\n  var appStream;\n  if(!master)\n    return;\n\n  var appStream = logFileService(moduleConfig);\n\n  function timestamp() {\n    return '[' + new Date().toISOString() + ']';\n  }\n\n  function logNotice(msg) {\n    appStream.write(timestamp() + ' ' + msg + \"\\n\");\n\n  }\n  function logError(msg) {\n    appStream.write(timestamp() + ' ' + msg + \"\\n\");\n  }\n\n  master.on('logNotice', logNotice);\n  master.on('logError', logError);\n\n  // second instance of Logging will load after reload, unbind event handlers\n  master.once('reload', function() {\n    master.removeListener('logNotice', logNotice);\n    master.removeListener('logError', logError);\n  });\n\n  function logFunction() {\n    var args = Array.prototype.slice.call(arguments);\n    args.unshift('[' + new Date().toISOString() + ']');\n    str = util.format.apply(this, args) + \"\\n\";\n    appStream.write(str);\n  }\n\n  return {\n    notice: logNotice,\n    error: logError\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-http-master/node_modules/http-master/modules/letsencrypt.js":"'use strict';\n\nmodule.exports = function LetsEncrypt(commService, master, worker, moduleConfig, config) {\n  let comm = commService('letsencrypt');\n  let Promise = require('bluebird');\n  let tls = require('tls');\n\n  if(!moduleConfig.email) {\n    throw new Error('letsencrypt.email needs to be set for the module to work');\n  }\n  if(!moduleConfig.agreeTos) {\n    throw new Error('letsencrypt.agreeTos needs to be set for the module to work');\n  }\n\n  if(!master) {\n    let whitelist = {};\n        \n    Object.keys(moduleConfig.domains || {})\n      .forEach(domain => {\n        whitelist[domain] = true;\n        whitelist['www.' + domain] = true;\n      });\n    process.on('dispatchTable', table => {\n      Object.keys(table).map(entry => entry = entry.split(/:/)[0])\n        .forEach(domain => whitelist[domain] = true);\n    });\n    \n    var leSni = require('le-sni-auto').create({\n      renewWithin: 10 * 24 * 60 * 60 * 1000       // do not renew prior to 10 days before expiration\n      , renewBy: 5 * 24 * 60 * 60 * 1000         // do not wait more than 5 days before expiration\n      // key (privkey.pem) and cert (cert.pem + chain.pem) will be provided by letsencrypt\n      , tlsOptions: { rejectUnauthorized: true, requestCert: false, ca: null, crl: null }\n      , getCertificatesAsync: function (domain, certs) {\n          return comm.request('getCertificates', {\n            domain: domain,\n            certs: certs\n          });\n      }\n    });\n    worker.fallbackSniCallback = (hostname, cb, sslConfig) => {\n      if(sslConfig.letsencrypt && whitelist[hostname]) {\n        return leSni.sniCallback(hostname, cb);\n      } else cb(null);\n    };\n    \n    worker.middleware.push(function() {\n      return {\n        requestHandler(req, res, next) {\n          var acmeChallengePrefix = '/.well-known/acme-challenge/';\n          if(req.url.indexOf(acmeChallengePrefix) !== 0) {\n            return next();\n          }\n          var key = req.url.slice(acmeChallengePrefix.length);\n          comm.request('acmeChallenge', {\n            key: key,\n            host: req.headers.host\n          }).then(val => res.end(val || '_'))\n          .catch(err => {\n            res.statusCode = 500;\n            res.end('Error')\n          });\n        }\n      }\n    });\n    return;\n  }\n  \n  let LEX = require('greenlock');\n  var leChallenge = require('le-challenge-standalone').create({ debug: true });\n  let lex = LEX.create({\n    debug: !!process.env.LETSENCRYPT_DEBUG,\n    server: process.env.LETSENCRYPT_STAGING ? 'staging' : LEX.productionServerUrl,\n    configDir: moduleConfig.configDir,\n    challenge: leChallenge,\n    approveDomains(opts, certs, cb) { // leave `null` to disable automatic registration\n      let hostname = opts.domain;\n      // Note: this is the place to check your database to get the user associated with this domain\n      let email = moduleConfig.email;\n      if(moduleConfig.domains &&\n        moduleConfig.domains[hostname] &&\n        moduleConfig.domains[hostname].email) {\n        email = moduleConfig.domains[hostname].email;\n      }\n      if (certs) {\n        opts.domains = certs.altnames;\n      }\n      else {\n        opts.email = email;\n        opts.agreeTos = moduleConfig.agreeTos;\n      }\n      cb(null, {options: opts, certs: certs});\n    }\n  });\n  lex = Promise.promisifyAll(lex);\n  lex.challenge = Promise.promisifyAll(lex.challenge);\n    \n  comm.onRequest('acmeChallenge', (data) => {\n    return lex.challenge.getAsync(lex, data.host, data.key);\n  });\n    \n  let getCertificatesAsync = require('memoizee')(lex.getCertificatesAsync, {\n    maxAge: 10000, // prevent DoS\n    promise: 'then' // cache also errors\n  });\n  \n  comm.onRequest('getCertificates', data => {\n    return getCertificatesAsync(data.domain, data.certs);\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-http-master/node_modules/http-master/src/DispatchTable.js":"'use strict';\nvar XRegExp = require('xregexp');\nvar assert = require('assert');\n\n// globStringToRegex from: http://stackoverflow.com/a/13818704/403571\nfunction regexpQuote(str, delimiter) {\n  // http://kevin.vanzonneveld.net\n  // +   original by: booeyOH\n  // +   improved by: Ates Goral (http://magnetiq.com)\n  // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n  // +   bugfixed by: Onno Marsman\n  // +   improved by: Brett Zamir (http://brett-zamir.me)\n  // *     example 1: preg_quote(\"$40\");\n  // *     returns 1: '\\$40'\n  // *     example 2: preg_quote(\"*RRRING* Hello?\");\n  // *     returns 2: '\\*RRRING\\* Hello\\?'\n  // *     example 3: preg_quote(\"\\\\.+*?[^]$(){}=!<>|:\");\n  // *     returns 3: '\\\\\\.\\+\\*\\?\\[\\^\\]\\$\\(\\)\\{\\}\\=\\!\\<\\>\\|\\:'\n  return (str + '').replace(new RegExp('[.\\\\\\\\+*?\\\\[\\\\^\\\\]$(){}=!<>|:\\\\' + (delimiter || '') + '-]', 'g'), '\\\\$&');\n}\n\nfunction splitFirst(str) {\n  var m = str.match(/^(\\^?[^\\/]*)\\$?(?:(\\/)(\\^?)(.*))?$/);\n  if(m.length > 2) {\n    // make ^/path from /^path\n    return [m[1], m[3] + m[2]+m[4]]; \n  }\n  return [m[1]];\n}\n\nfunction globStringToRegex(str, specialCh, optionalEnding) {\n  if(!specialCh)\n    specialCh = '.';\n  var inside = regexpQuote(str);\n  if(specialCh == '.') {\n    inside = inside.replace(/^\\\\\\*$/g, '(?:(?<host>.*))');\n    inside = inside.replace(/^\\\\\\*\\\\\\?\\\\\\./g, '(?:(.+)\\\\.)?');\n    inside = inside.replace(/^\\\\\\*\\\\\\./g, '(?:(.+)\\\\.)');\n    inside = inside.replace(/\\\\\\.\\\\\\*\\\\\\?/g, '(?:\\\\.([^'+specialCh+']+))?');    \n  }\n  else\n    inside = inside.replace(/\\/\\\\\\*$/g, '(?:\\/(?<rest>.*|)|)');\n  inside = inside.replace(/\\\\\\*/g, '([^'+specialCh+']+)');\n\n  var regexp = new XRegExp('^' + inside + (optionalEnding?('(?:'+optionalEnding+')?'):'') +  '$');\n  return regexp;\n}\n\nfunction getRegexpIfNeeded(str, specialCh, optionalEnding) {\n  if (typeof str == 'string') {\n    var m = str.match(/^\\^(.*)\\$?$/);\n    if (m) {\n      return new XRegExp('^' + m[1] + (optionalEnding?('(?:'+optionalEnding+')?'):'') +  '$');\n    } else if (str.match(/[*?]/)) {\n      return globStringToRegex(str, specialCh, optionalEnding);\n    }\n  }\n  return undefined;\n}\n\nfunction postParseKey(entryKey, entry) {\n  var regexp = getRegexpIfNeeded(entryKey, '.', ':' + entry.port);\n  if (regexp)\n    entry.regexp = regexp;\n  return entryKey;\n}\n\nfunction DispatchTable(port, params) {\n  var parseEntry = params.entryParser;\n  var config = params.config;\n\n  var self = this;\n  this.requestHandler = params.requestHandler;\n  this.upgradeHandler = params.upgradeHandler;\n  this.table = {};\n  this.regexpEntries = [];\n  this.failedEntries = {};\n  Object.keys(config || {}).forEach(function(entryKey) {\n    var entry = config[entryKey];\n\n\n    // split entry 192.168.0.0/host to\n    // ['192.168.0.0', '/']\n    var entryKeyData = splitFirst(entryKey);\n    entryKey = entryKeyData[0];\n    var entryPath = entryKeyData[1];\n\n    if(entryPath) {\n      entryPath = decodeURIComponent(entryPath);\n    }\n    if (parseEntry) {\n      var parsedEntry = parseEntry(entry);\n      assert(typeof parsedEntry !== 'undefined', 'entryParser should have returned something');\n      entry = parsedEntry;\n    }\n    entry = {\n      target: entry,\n      port: port\n    };\n    if (entryPath) {\n      entry.path = entryPath;\n      var pathRegexp = getRegexpIfNeeded(entryPath, '\\/');\n      if (pathRegexp)\n        entry.pathRegexp = pathRegexp;\n    }\n    entryKey = postParseKey(entryKey, entry);\n    port = port || 80;\n\n    if (entry.regexp) {\n      self.regexpEntries.push(entry);\n    } else {\n      if (self.table[entryKey]) {\n        if (self.table[entryKey] instanceof Array) {\n          self.table[entryKey].push(entry);\n          self.table[entryKey + ':' + port].push(entry);\n        } else {\n          var oldEntry = self.table[entryKey];\n          self.table[entryKey] = [oldEntry, entry];\n          self.table[entryKey + ':' + port] = [oldEntry, entry];\n        }\n      } else {\n        self.table[entryKey + ':' + port] = entry;\n        self.table[entryKey] = entry;\n      }\n    }\n  });\n}\n\nDispatchTable.prototype.checkPathForReq = function(req, entry) {\n  if(!entry.path)\n    return true;\n  var m;\n\n  var parsedUrl = req.parsedUrl;\n  var pathname = parsedUrl.pathname || '';\n\n  try {\n    pathname = decodeURIComponent(pathname);\n  } catch(err) {}\n\n  if(entry.pathRegexp) {\n    m = pathname.match(entry.pathRegexp);\n    if (m) {\n      if(!req.match)\n        req.match = [];\n      for(var i = 1;i < m.length;++i) {\n        req.match.push(m[i]);\n      }\n      return true;\n    } \n  }\n  else if(pathname == entry.path) {\n    return true;\n  }\n  return false;\n};\n\nDispatchTable.prototype.getTargetForReq = function(req) {\n  var i, m;\n  var host = req.unicodeHost || req.headers.host || ''; // host can be undefined\n\n  var self = this;\n  var target;\n\n  // look for specific host match first\n  // and generic path-only match then\n  [host, ''].some(function(host) {\n    var entry = self.table[host];\n    if (entry) {\n      if (entry.target) {\n        if(self.checkPathForReq(req, entry)) {\n          target = entry.target\n          return true;\n        }\n      }\n      else { // multiple entries, check pathnames\n        var targetEntries = entry;\n        for (i = 0; i < targetEntries.length; ++i) {\n          if(self.checkPathForReq(req, targetEntries[i])) {\n            target = targetEntries[i].target;\n            return true;\n          }\n        }\n      }\n    }\n  });\n  if(target) {\n    return target;\n  }\n  // if host-only matches failed, look for path matches\n  if (this.regexpEntries.length) {\n    var regexpEntries = this.regexpEntries;\n    for (i = 0; i < regexpEntries.length; ++i) {\n      var entry = regexpEntries[i];\n      if(!entry.regexp) {\n        // TODO: research this\n        continue;\n      }\n      m = host.match(entry.regexp);\n      if (m) {\n        if(!req.match)\n          req.match = [];\n        for(var i = 1;i < m.length;++i)\n          req.match.push(m[i]);\n        if(this.checkPathForReq(req, entry)) {\n          return entry.target;\n        }\n      }\n    }\n  }\n};\n\nDispatchTable.prototype.dispatchRequest = function(req, res, next) {\n  var target = this.getTargetForReq(req);\n  if(target && this.requestHandler) {\n    return this.requestHandler(req, res, next, target);\n  }\n  next();\n};\n\nDispatchTable.prototype.handleRequest = DispatchTable.prototype.dispatchRequest;\n\nmodule.exports = DispatchTable;\n\nmodule.exports.regexpQuote = regexpQuote;","/home/travis/build/npmtest/node-npmtest-http-master/node_modules/http-master/src/HttpMasterWorker.js":"'use strict';\nvar crypto = require('crypto');\nvar net = require('net');\nvar http = require('http');\nvar async = require('async');\nvar regexpQuote = require('./DispatchTable').regexpQuote;\nvar tls = require('tls');\nvar DI = require('./di');\nvar path = require('path');\nvar extend = require('extend');\nvar ocsp = require('ocsp');\nlet Promise = require('bluebird');\n\nvar nodeVersion = Number(process.version.match(/^v(\\d+\\.\\d+)/)[1]);\n\nvar EventEmitter = require('eventemitter3');\n\nvar punycode = require('punycode');\n\nvar createCredentials;\nif (tls.createSecureContext) {\n  createCredentials = tls.createSecureContext;\n} else {\n  createCredentials = crypto.createCredentials;\n}\n\nfunction lazyGetTcpServer(port, host, cb) {\n  var tcpServers = this.tcpServers;\n\n  var entry = (host ? host + ':' + port : port);\n  if (tcpServers[entry]) {\n    cb(null, tcpServers[entry]);\n  } else {\n    var tcpServer = tcpServers[entry] = net.createServer();\n\n    var handler = function(err) {\n      if (err) return cb(err);\n      cb(null, tcpServer);\n    };\n    try {\n      if (host)\n        tcpServer.listen(port, host, handler);\n      else\n        tcpServer.listen(port, handler);\n      tcpServer.once('error', function(err) {\n        delete tcpServers[entry];\n        cb(err);\n      });\n    } catch (err) {\n      cb(err);\n    }\n  }\n}\n\nfunction loadKeysforConfigEntry(config, callback) {\n  var key;\n  if(config.ssl === true) {\n    config.ssl = {};\n  }\n  if (config.ssl) {\n    var SNI = config.ssl.SNI;\n    var SNImatchers = {};\n    if (config.ssl.SNI) {\n      for (key in config.ssl.SNI) {\n        SNImatchers[key] = new RegExp('^' + regexpQuote(key).replace(/^\\\\\\*\\\\\\./g, '^([^.]+\\\\.)?') + '$', 'i'); // domain names are case insensitive\n      }\n    }\n    var sniCallback = (hostname, cb) => {\n      hostname = punycode.toUnicode(hostname);\n      for (var key in SNI) {\n        if (hostname.match(SNImatchers[key])) {\n          if (cb) // since node 0.11.5\n            return cb(null, SNI[key]);\n          else\n            return SNI[key];\n        }\n      }\n      if(this.fallbackSniCallback) {\n        return this.fallbackSniCallback(hostname, cb, config.ssl);\n      }\n      return cb(null);\n    };\n    config.ssl.SNICallback = sniCallback;\n\n    if (SNI) {\n      var todo = [];\n      for (key in SNI) {\n        todo.push(key);\n      }\n\n      async.each(todo, function(key, sniLoaded) {\n        if (config.ssl.spdy && SNI[key].spdy === false) {\n          SNI[key].NPNProtocols = ['http/1.1', 'http/1.0'];\n          SNI[key].ALPNProtocols = ['http/1.1', 'http/1.0'];\n        }\n\n        SNI[key].ciphers = SNI[key].ciphers || config.ssl.ciphers;\n        SNI[key].honorCipherOrder = SNI[key].honorCipherOrder || config.ssl.honorCipherOrder;\n        SNI[key].ecdhCurve = SNI[key].ecdhCurve || config.ssl.ecdhCurve;\n\n        // joyent/node#7249\n        if (SNI[key].honorCipherOrder) {\n          SNI[key].secureOptions = require('constants').SSL_OP_CIPHER_SERVER_PREFERENCE;\n        }\n        if (!SNI[key].ecdhCurve) {\n          SNI[key].ecdhCurve = require('tls').DEFAULT_ECDH_CURVE;\n        }\n        try {\n          var credentials = createCredentials(SNI[key]);\n          SNI[key] = credentials.context;\n          sniLoaded();\n        } catch (err) {\n          sniLoaded(err);\n        }\n      }, callback);\n    } else { // (!SNI)\n      callback();\n    }\n    //    });\n  } else { // (!config.ssl)\n    callback();\n  }\n}\n\nfunction handlePortEntryConfig(host, portNumber, portEntryConfig, callback) {\n  loadKeysforConfigEntry.call(this, portEntryConfig, err => {\n    if (err) {\n      return callback(err);\n    }\n    handleConfigEntryAfterLoadingKeys.call(this, host, portNumber, portEntryConfig, callback);\n  });\n}\n\nfunction patchSslConfig(portEntrySslConfig) {\n  if (nodeVersion >= 0.11) { // use fancy cipher settings only for 0.11\n    if (portEntrySslConfig.honorCipherOrder !== false) {\n      // prefer server ciphers over clients - prevents BEAST attack\n      portEntrySslConfig.honorCipherOrder = true;\n    }\n    if (!portEntrySslConfig.ciphers) {\n      portEntrySslConfig.ciphers = 'EECDH+ECDSA+AESGCM:EECDH+aRSA+AESGCM:EECDH+ECDSA+SHA384:EECDH+ECDSA+SHA256:EECDH+aRSA+SHA384:EECDH+aRSA+SHA256:EECDH+aRSA+AES+SHA:EECDH+aRSA+RC4:EECDH:EDH+aRSA:RC4:!aNULL:!eNULL:!LOW:!3DES:!MD5:!EXP:!PSK:!SRP:!DSS::+RC4:RC4';\n      if (portEntrySslConfig.disableWeakCiphers) {\n        portEntrySslConfig.ciphers += ':!RC4';\n      }\n    } else if (portEntrySslConfig.disableWeakCiphers) {\n      this.logNotice('disableWeakCiphers is incompatible with pre-set cipher list');\n    }\n  } else if (portEntrySslConfig.disableWeakCiphers) {\n    this.logNotice('disableWeakCiphers is unsupported for node 0.10');\n  }\n}\n\n\n\nfunction createHandlers(portNumber, portConfig) {\n  var self = this;\n\n  var di = this.di.makeChild();\n  di.bindInstance('di', di);\n\n  di.bindInstance('portConfig', portConfig);\n  di.bindInstance('portNumber', portNumber);\n\n  di.onMissing = function(name) {\n\n    var m;\n    if ((m = name.match(/(.+)Middleware$/))) {\n      name = m[1];\n      try {\n        di.bindType(name + 'Middleware', require('../' + path.join('modules/middleware/', name)));\n      } catch (err) {\n        console.log(err && err.message);\n        return;\n      }\n      return di.resolve(name + 'Middleware');\n    }\n  };\n\n  var router = di.resolve('routerMiddleware');\n\n  // allow also for specifying 80: 'http://code2flow.com:8080'\n  if (typeof portConfig !== 'object' || portConfig instanceof Array) {\n    portConfig = {\n      router: portConfig\n    };\n  }\n\n  if (!(portConfig.router instanceof Array)) {\n    portConfig.router = [portConfig.router];\n  }\n\n  portConfig.router = [].concat(self.middleware)\n    .concat(self.config.middleware || [])\n    .concat(portConfig.middleware || [])\n    .concat(portConfig.router);\n\n  var reject = di.resolve('rejectMiddleware');\n\n  var target = router.entryParser(portConfig.router);\n  return {\n    request: function(req, res, next) {\n      router.requestHandler(req, res, next, target);\n    },\n    error: function(err, req, res) {\n      var code = 500;\n      if (!err)\n        code = 503;\n      reject.requestHandler(req, res, null, reject.entryParser(500));\n    }\n  };\n}\n\n\nfunction serverForPortConfig(host, portNumber, portConfig) {\n  var self = this;\n  var server;\n\n  self.cachedServers = self.cachedServers || {};\n  var key = (host ? host + ':' + portNumber : portNumber);\n\n\n  var sslCachedConfig = extend({}, portConfig.ssl);\n  delete sslCachedConfig.SNI;\n\n  var cached = self.cachedServers[key];\n  if (cached) {\n    server = self.cachedServers[key].server;\n    server.removeAllListeners();\n    if (JSON.stringify(sslCachedConfig) === cached.sslConfig) {\n      return server;\n    }\n  }\n\n  if (portConfig.ssl) {\n    var baseModule = portConfig.ssl.spdy ? require('spdy') : require('https');\n\n    patchSslConfig.call(self, portConfig.ssl);\n\n    if (self.token) {\n      portConfig.ticketKeys = self.token;\n    }\n\n    server = baseModule.createServer(portConfig.ssl);\n\n    var cache = this.ocspCache = this.ocspCache || new ocsp.Cache();\n    server.on('OCSPRequest', function(cert, issuer, cb) {\n      if(!cert) {\n        return cb(new Error('empty certificate passed'));\n      }\n      try {\n        ocsp.getOCSPURI(cert, function(err, uri) {\n          if (err) {\n            return cb(err);\n          }\n          if(uri === null) {\n            // handle not working OCSP server\n            return cb();\n          }\n          var req = ocsp.request.generate(cert, issuer);\n          var options = {\n            url: uri,\n            ocsp: req.data\n          };\n          cache.request(req.id, options, function(err, response) {\n            if(err) {\n              console.error('Ignoring OCSP error', err);\n              return cb();\n            }\n            cb(null, response);\n          });\n        });\n      } catch(err) {\n        console.error('Ignoring OCSP error', err);\n        return cb();\n      }\n    });\n\n    if (!portConfig.ssl.skipWorkerSessionResumption) {\n      server.on('resumeSession', self.tlsSessionStore.get.bind(self.tlsSessionStore));\n      server.on('newSession', self.tlsSessionStore.set.bind(self.tlsSessionStore));\n    }\n  } else {\n    server = http.createServer();\n  }\n\n\n  self.cachedServers[key] = {\n    server: server,\n    sslConfig: JSON.stringify(sslCachedConfig)\n  }\n  return server;\n}\n\nfunction handleConfigEntryAfterLoadingKeys(host, portNumber, config, callback) {\n  var self = this;\n\n  var handlers = createHandlers.call(this, portNumber, config);\n\n  var handler = require('./requestHandler')(handlers.request, handlers.error);\n\n  var server;\n  try {\n    server = serverForPortConfig.call(this, host, portNumber, config);\n    server.removeAllListeners('request');\n    server.on('request', handler);\n  } catch (err) {\n    return callback(err, null);\n  }\n\n  function listeningHandler() {\n    server.removeAllListeners('error'); // remove the below handler\n    callback(null, server);\n    server.removeListener('error', errorHandler);\n  }\n\n  function errorHandler(err) {\n    server.removeAllListeners('listening'); // remove the above handler\n    callback(err, server);\n    server.removeListener('listening', listeningHandler);\n  }\n\n  server.once('listening', listeningHandler);\n  server.once('error', errorHandler);\n\n  server.removeAllListeners('upgrade');\n  server.on('upgrade', function(req, socket, head) {\n    req.upgrade = {\n      socket: socket,\n      head: head\n    };\n    handler(req, { // fake res object for log middleware to work\n      socket: socket\n    });\n  });\n\n  lazyGetTcpServer.call(self, portNumber, host, function(err, tcpServer) {\n    if (err) return callback(err, null);\n\n    tcpServer.removeAllListeners();\n    tcpServer.on('connection', function(socket) {\n      server.emit('connection', socket);\n    });\n    tcpServer.on('error', function(err) {\n      server.emit('error', err);\n    });\n    tcpServer.on('close', function(err) {\n      server.emit('close');\n    });\n    server.emit('listening');\n  });\n}\n\nfunction handleConfig(config, configHandled) {\n  var self = this;\n\n  self.config = config;\n\n  var errors = {};\n\n  if (config.disableTlsClientRenegotiation) {\n    tls.CLIENT_RENEG_LIMIT = 0;\n    tls.CLIENT_RENEG_WINDOW = 0;\n  }\n\n  async.parallel(Object.keys(config.ports || {}).map(function(portEntry) {\n    return function(asyncCallback) {\n      var m;\n      // TODO: IPV6?\n      if ((m = portEntry.match(/((\\S+):)?(\\d+)/))) {\n        var listenHost = m[2];\n        var listenPortNumber = parseInt(m[3]);\n\n        var portConfig = config.ports[portEntry];\n\n        handlePortEntryConfig.call(self, listenHost, listenPortNumber, portConfig, function(err, server) {\n          var entryString = (listenHost ? listenHost + ':' + listenPortNumber : 'port ' + listenPortNumber);\n          if (err) {\n            self.logError('Error while starting entry ' + entryString + ' : ' + err.toString());\n            if (err.stack)\n              self.logError(err.stack);\n            errors[portEntry] = err;\n          }\n          if (server) {\n            self.logNotice('Listening on port: ' + entryString);\n          } else\n            self.logNotice('Entry ' + entryString + ' is unusable');\n          // ignore error to not crash the entire proxy\n          asyncCallback(null, server);\n        });\n      }\n    };\n  }), function(err, results) {\n    // if (err) {\n    //   return configHandled(err);\n    // }\n    self.logNotice('Start successful');\n\n    self.servers = results.filter(function(server) {\n      return !!server;\n    });\n    if (Object.keys(errors).length == 0) {\n      configHandled(null);\n    } else {\n      configHandled(errors);\n    }\n  });\n}\n\nfunction unbindAll(cb) {\n  this.servers.forEach(function(server) {\n    server.unref();\n  });\n  this.servers = [];\n  var self = this;\n  Object.keys(this.tcpServers).forEach(function(key) {\n    self.tcpServers[key].removeAllListeners();\n  });\n  cb();\n}\n\nfunction HttpMasterWorker(config) {\n  config = config || {};\n  this.config = config;\n  this.middleware = [];\n  var store = {};\n  this.tlsSessionStore = config.tlsSessionStore || {\n    get: function(id, cb) {\n      id = id.toString('base64');\n      cb(null, store[id], null);\n    },\n    set: function(id, data, cb) {\n      id = id.toString('base64');\n      store[id] = data;\n      // todo cleanup old ids\n      if (cb)\n        cb();\n    }\n  };\n  this.tcpServers = {};\n  this.servers = [];\n}\n\nHttpMasterWorker.prototype = Object.create(EventEmitter.prototype);\n\nHttpMasterWorker.prototype.logNotice = function(msg) {\n  this.emit('logNotice', msg);\n};\n\nHttpMasterWorker.prototype.logError = function(msg) {\n  this.emit('logError', msg);\n};\n\nHttpMasterWorker.prototype.unbindAll = function(unbindFinished) {\n  unbindAll.call(this, unbindFinished);\n};\n\nHttpMasterWorker.prototype.loadConfig = function(config, configLoaded) {\n  var self = this;\n\n  var events = new EventEmitter();\n\n  this.config = config;\n\n  function messageHandler(msg) {\n    events.emit('msg:' + msg.type, msg.data, msg.workerId);\n  }\n  this.handleMessage = messageHandler;\n\n  this.unbindAll(function() {});\n  if (this.di) {\n    this.emit('reload');\n  }\n  var di = this.di = new DI();\n\n  di.onMissing = function(name) {\n    var m;\n    if ((m = name.match(/(.+)Service$/))) {\n      name = m[1];\n      try {\n        this.bindType(name + 'Service', require(path.join(__dirname, '..', 'modules/services/', name)));\n      } catch (err) {\n        console.log(err && err.message);\n        return;\n      }\n      self.emit('loadService', name);\n      return this.resolve(name + 'Service');\n    }\n  };\n\n  di.bindInstance('di', di);\n  di.bindInstance('worker', this);\n\n  this.once('reload', function() {\n    process.removeListener('msg', messageHandler);\n    events.emit('reload');\n    events.removeAllListeners();\n  });\n\n  di.bindInstance('events', events);\n  di.bindResolver('config', function() {\n    return self.config;\n  });\n  di.bindInstance('master', null);\n  Object.keys(config.modules || {}).forEach(function(moduleName) {\n    if (!config.modules[moduleName])\n      return;\n    var di = self.di.makeChild();\n    di.bindInstance('di', di);\n    di.bindInstance('moduleConfig', config.modules[moduleName]);\n    try {\n      di.resolve(require(path.join(__dirname, '..', 'modules', moduleName)));\n    } catch (err) {\n      console.error(\"Error loading module:\", moduleName, err);\n    }\n  });\n\n  handleConfig.call(this, config, function(err) {\n    self.gcServers(function() {\n      if (configLoaded)\n        configLoaded(err);\n    });\n  });\n};\n\nHttpMasterWorker.prototype.gcServers = function(gcFinished) {\n  var self = this;\n  var toClose = [];\n\n  Object.keys(this.tcpServers).forEach(function(key) {\n    var server = self.tcpServers[key];\n    if (require('events').EventEmitter.listenerCount(server, 'connection') === 0) {\n      toClose.push(server);\n      delete self.tcpServers[key];\n      if (self.cachedServers[key]) {\n        self.cachedServers[key].server.removeAllListeners();\n        delete self.cachedServers[key];\n      }\n    }\n  });\n  async.each(toClose, function(server, cb) {\n    server.close();\n    cb();\n  }, gcFinished);\n};\n\nmodule.exports = HttpMasterWorker;\n","/home/travis/build/npmtest/node-npmtest-http-master/node_modules/http-master/src/requestHandler.js":"var http = require('http');\nvar parseurl = require('parseurl');\n\nvar punycode = require('punycode');\n\nmodule.exports = function(handler, finalHandler) {\n  return function(req, res) {\n    req.parsedUrl = parseurl(req);\n\n    if(req.headers.host) { // this legally can be undefined\n      var hostSplit = req.headers.host.split(':');\n      try {\n        hostSplit[0] = punycode.toUnicode(hostSplit[0]);\n        req.unicodeHost = hostSplit.join(\":\");\n      } catch(err) {\n        req.unicodeHost = req.headers.host;\n      }\n    }\n    handler(req, res, function(err) {\n      if(finalHandler) {\n        finalHandler(err, req, res);\n      }\n    });\n  };\n};","/home/travis/build/npmtest/node-npmtest-http-master/node_modules/http-master/src/testUtils.js":"var net = require('net');\nvar async = require('async');\n\nexports.findPort = function(fn) {\n  var net = require('net')\n  var tester = net.createServer();\n  var port;\n  tester.once('error', function (err) {\n    if (err.code !== 'EADDRINUSE') return fn(err)\n    exports.findPort(fn);\n  })\n  .once('listening', function() {\n    port = tester.address().port;\n    tester.once('close', function() {\n      fn(null, port);\n    })\n    tester.close();\n  })\n  .listen(0);\n};\n\nexports.findPorts = function(num, cb) {\n  async.times(num, function(n, cb) {\n    exports.findPort(cb);\n  }, function(err, port) {\n    cb(err, port);\n  }, cb);\n}\n\nexports.assurePortNotListening =function(port, cb) {\n  var client = net.connect({\n      port: port\n    },\n    function() {\n      throw new Error('Port ' + port + ' should have been not listening');\n    });\n  client.once('error', function(err) {\n    cb();\n  });\n};\n\nexports.assurePortIsListening = function(port, cb) {\n  var client = net.connect({\n      port: port\n    },\n    function() {\n      cb();\n    });\n  client.once('error', function(err) {\n    throw new Error('Port ' + port + ' should have been listening');\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-http-master/node_modules/http-master/src/worker.js":"var config = {};\nvar cluster = require('cluster');\nvar util = require('util');\n\nvar droppedPrivileges = false;\n\nprocess.title = 'http-master-worker#' + cluster.worker.id;\n\nfunction logError(str) {\n  console.log('[' + cluster.worker.id + '] ' + str);\n}\nvar logNotice = logError;\n\nif(process.env.NODE_ENV === 'production') {\n  console.log = function() {\n    process.sendMessage(\"logNotice\", util.format.apply(this, arguments));\n  };\n  console.error = function() {\n    process.sendMessage(\"logError\", util.format.apply(this, arguments));\n  };\n}\n\n// TODO: move to common\nfunction dropPrivileges() {\n  var strInfo;\n  if (process.setgid) {\n    var group = config.group;\n    if (typeof group === 'string') {\n      process.setgid(group);\n      strInfo = group;\n    }\n  }\n  if (process.setuid) {\n    var user = config.user;\n    if (typeof user === 'string') {\n      process.setuid(user);\n      if (strInfo)\n        strInfo = user + \":\" + strInfo;\n      else\n        strInfo = user;\n    }\n  }\n  if (!droppedPrivileges && strInfo)\n    logNotice(\"Dropped privileges to: \" + strInfo);\n  droppedPrivileges = true;\n}\n\n\nvar HttpMasterWorker = require('./HttpMasterWorker');\nvar worker = new HttpMasterWorker({\n  tlsSessionStore: {\n    get: function(id, cb) {\n      process.once('msg:session:' + id.toString('base64'), function(data) {\n        cb(null, data.length ? new Buffer(data, 'base64') : null, null);\n      });\n      process.sendMessage('tlsSession:get', id.toString('base64'));\n    },\n    set: function(id, data, cb) {\n      process.sendMessage('tlsSession:set', {\n        id: id.toString('base64'),\n        data: data.toString('base64')\n      });\n      if (cb)\n        cb();\n    }\n  }\n});\n\nworker.on('logNotice', logNotice);\nworker.on('logError', logError);\n\nprocess.sendMessage = function(type, data) {\n  process.send(JSON.stringify({\n    type: type,\n    data: data,\n    workerId: cluster.worker.id\n  }));\n};\n\nworker.sendMessage = process.sendMessage;\n\nworker.on('loadService', function(service) {\n  process.sendMessage('masterLoadService', service);\n});\n\nvar JSONfn = require('jsonfn').JSONfn;\n\nprocess.on('message', function(msg) {\n  msg = JSONfn.parse(msg);\n  process.emit('msg', {\n    type: msg.type,\n    data: msg.data\n  });\n  process.emit('msg:' + msg.type, msg.data);\n});\n\nprocess.on('uncaughtException', function(err) {\n  logError(\"[Uncaught exception] \" + err.stack || err.message);\n  process.exit(1);\n});\n\nprocess.on('msg:start', function(data) {\n  config = data.config;\n  process.emit('initWorker');\n\n  dropPrivileges();\n  worker.token = data.token;\n  worker.loadConfig(data.config, function(err) {\n    // if (err) {\n    //   process.sendMessage('exception', err);\n    //   logError(\"Exitting worker due to error: \" + err.toString());\n    //   return process.exit();\n    // }\n    process.sendMessage(\"started\", err);\n  });\n});\n\nprocess.on('msg:unbind', function() {\n  logNotice('Reloading config');\n  worker.unbindAll(function() {\n    process.sendMessage(\"unbindFinished\");\n  });\n});\n\nprocess.on('msg', function(data) {\n  if (worker.handleMessage)\n    worker.handleMessage(data);\n});\n\nvar originalLog = console.log;\nvar originalError = console.error;\n\nprocess.on('msg:reload', function(config) {\n  if (config.silent) {\n    console.log = function(msg) {};\n    console.error = function(msg) {};\n  } else {\n    console.log = originalLog;\n    console.error = originalError;\n  }\n\n  worker.loadConfig(config, function(err) {\n    // if (err) {\n    //   process.sendMessage('exception', err);\n    //   logError(\"Exitting worker due to error: \" + err.toString());\n    //   return process.exit();\n    // }\n    process.sendMessage(\"started\", err);\n  });\n});\n\nprocess.on('msg:unregister', function() {\n  process.removeAllListeners();\n});\n\nprocess.on('SIGINT', function() {});\n\nif(global.gc) { // if gc is exposed then utilize it\n  setInterval(function() {\n    global.gc();\n  }, 30000);\n}\n","/home/travis/build/npmtest/node-npmtest-http-master/node_modules/http-master/modules/middleware/addHeader.js":"module.exports = function AddHeaderMiddleware() {\n  return {\n    requestHandler: function(req, res, next, target) {\n      if(!req.upgrade) {\n        req.headers[target[0]] = target[1];\n      }\n      next();\n    },\n    entryParser: function(config) {\n      if(!config.match(/\\s*=\\s*/)) {\n        throw new Error('Bad format, should be key=value');\n      }\n      var m = config.match(/^(.*?)\\s*=\\s*(.*$)/);\n      m.shift();\n      return m;\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-http-master/node_modules/http-master/modules/middleware/addHeaderToResponse.js":"module.exports = function AddHeaderMiddleware() {\n  return {\n    requestHandler: function(req, res, next, target) {\n      if(!req.upgrade) {\n        res.setHeader(target[0], target[1]);\n      }\n      next();\n    },\n    entryParser: function(config) {\n      if(!config.match(/\\s*=\\s*/)) {\n        throw new Error('Bad format, should be key=value');\n      }\n      var m = config.match(/^(.*?)\\s*=\\s*(.*$)/);\n      m.shift();\n      return m;\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-http-master/node_modules/http-master/modules/middleware/auth.js":"var httpAuth = require('http-auth');\n\nmodule.exports = function AuthMiddleware() {\n  return {\n    requestHandler: function(req, res, next, auth) {\n      auth(req, res, function(err) {\n        delete req.headers.authorization;\n        next(err);\n      });\n    },\n    entryParser: function(authConfig) {\n\n      if(typeof authConfig === 'object') {\n        authConfig.realm = authConfig.realm || 'Enter password';\n      }\n      if(typeof authConfig === 'string') {\n        authConfig = {\n          file: authConfig,\n          realm: 'Enter password'\n        }\n      }\n      return httpAuth.connect(httpAuth.basic(authConfig));\n    }\n  };\n};","/home/travis/build/npmtest/node-npmtest-http-master/node_modules/http-master/modules/middleware/gzip.js":"var compression = require('compression');\n\nmodule.exports = function GzipMiddleware() {\n  return {\n    requestHandler: function(req, res, next, middlewareInstance) {\n      middlewareInstance(req, res, next);\n    },\n    entryParser: function(entry) {\n      return require('compression')({\n        level: parseInt(entry)\n      });\n    }\n  };\n};","/home/travis/build/npmtest/node-npmtest-http-master/node_modules/http-master/modules/middleware/proxy.js":"'use strict';\n\nvar http = require('http');\nvar https = require('https');\nvar httpProxy = require('http-proxy');\nvar url = require('url');\nvar regexpHelper = require('../../src/regexpHelper');\nvar assert = require('assert');\n\nfunction parseEntry(entry) {\n  var m;\n  if(typeof entry == 'number')\n    entry = entry.toString();\n\n  assert(typeof entry === 'string');\n\n  var withPath = false;\n  withPath = !!entry.replace(/https?:\\/\\//, '').match(/.*\\//);\n\n  if((m = entry.match(/^\\d+(?:|\\/.*)$/))) {\n    entry = '127.0.0.1:' + entry;\n  }\n  if(!entry.match(/https?:\\/\\//)) {\n    entry = 'http://' + entry;\n  }\n  entry = url.parse(entry, true, true);\n  entry.withPath = withPath;\n  return entry;\n}\n\nfunction getAgent(config, portConfig) {\n  let httpAgent = false, httpsAgent = false;\n  var agentSettings = portConfig.agentSettings || config.agentSettings;\n  if (agentSettings) {\n    httpAgent = new http.Agent(agentSettings);\n    httpsAgent = new https.Agent(agentSettings);\n  }\n  return {httpAgent, httpsAgent};\n}\n\nmodule.exports = function ProxyMiddleware(config, portConfig, di) {\n  var {httpAgent, httpsAgent} = getAgent(config, portConfig);\n  var proxyHttp = httpProxy.createProxyServer({xfwd: true, agent: httpAgent});\n  var proxyHttps = httpProxy.createProxyServer({xfwd: true, agent: httpsAgent, secure: false});\n  proxyHttp.on('error', function(err, req, res) {\n    req.err = err;\n    req.next(err);\n  });\n  proxyHttps.on('error', function(err, req, res) {\n    req.err = err;\n    req.next(err);\n  });\n\n  var rewriteTargetAndPathIfNeeded = function(req, target) {\n    if(!req.match) {\n      return target;\n    }\n\n    var processed = regexpHelper(target.href, req.match);\n\n    if (req.parsedUrl.search) {\n      processed += req.parsedUrl.search;\n    }\n\n    var newTarget = url.parse(processed);\n    if(target.withPath) {\n      req.url = newTarget.path;\n    }\n    return newTarget;\n  };\n\n  return {\n    requestHandler: function(req, res, next, dispatchTarget) {\n      req.next = next;\n      // workaround for node-http-proxy/#591\n      if(!req.headers.host) {\n        req.headers.host = '';\n      }\n            \n      var proxyTarget = rewriteTargetAndPathIfNeeded(req, dispatchTarget);\n      var m = req.headers.host.match(/^(.+):(\\d+)$/);\n      if(m) {\n        req.headers.host = m[1] + ':' + m[2];\n      }\n\n      // work around weirdness of new http-proxy url handling\n      // for the purpose of passing the tests\n      if(proxyTarget.pathname !== '/') {\n        req.url = '';\n      }\n      else {\n        proxyTarget.path = '';\n      }\n      let proxy = proxyTarget.protocol === 'https:' ? proxyHttps : proxyHttp;\n      let agent = proxyTarget.protocol === 'https:' ? httpsAgent : httpAgent;\n      req.__proxy = proxy;\n      req.__agent = agent;\n\n      var options = {\n        target: proxyTarget,\n        proxyTimeout: portConfig.proxyTargetTimeout,\n        timeout: portConfig.proxyTimeout,\n        toProxy: true\n      };\n\n      if(req.upgrade) {\n        return proxy.ws(req, req.upgrade.socket, req.upgrade.head, options);\n      }\n      proxy.web(req, res, options);\n    },\n    entryParser: function(entry) {\n      return parseEntry(entry.target || entry);\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-http-master/node_modules/http-master/modules/middleware/redirect.js":"\nvar regexpHelper = require('../../src/regexpHelper');\n\nmodule.exports = function RedirectMiddleware() {\n  return {\n    requestHandler: function(req, res, next, target) {\n      // skip for websockets\n      if(req.upgrade) { return next(); }\n      \n      if (req.match)\n        target = regexpHelper(target, req.match);\n\n      target = target.replace(\"[path]\", req.url.substring(1));\n      if(req.unicodeHost) {\n        target = target.replace(\"[host]\", req.unicodeHost.split(':')[0]);\n      }\n      res.statusCode = 302;\n      res.setHeader(\"Location\", target);\n      return res.end();\n    }\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-http-master/node_modules/http-master/modules/middleware/reject.js":"var http = require('http');\nvar fs = require('fs');\nvar path = require('path');\n\nfunction loadHtmlFile(errorHtmlFile) {\n  var content = fs.readFileSync(errorHtmlFile).toString('utf8');\n  content = content.replace(/src=\"(.+?)\"/g, function(m, fileName) {\n    var imagePath = path.join(path.dirname(errorHtmlFile), fileName);\n    return 'src=\"data:image/'+path.extname(fileName).substr(1)+';base64,' + fs.readFileSync(imagePath).toString('base64') + '\"';\n  });\n  return content;\n}\n\nmodule.exports = function RejectMiddleware(config, portConfig) {\n  var content;\n  var errorHtmlFile = portConfig.errorHtmlFile || config.errorHtmlFile;\n  if(errorHtmlFile) {\n    if(typeof errorHtmlFile === 'function') {\n      content = errorHtmlFile();\n    } else {\n      content = loadHtmlFile(errorHtmlFile);\n    }\n  }\n\n  return {\n    requestHandler: function(req, res, next, target) {\n      if(req.upgrade) return;\n      res.statusCode = target.code;\n      var head = {};\n\n      content = target.html || content;\n\n      var contentType = req.headers['accept'] || '';\n\n      if(content && contentType.match(/text\\/html/)) {\n        head['Content-Type'] = 'text/html';\n        res.writeHead(target.code, head);\n        res.write(content);\n        res.end();\n      } else if(contentType.match(/application\\/json/)) {\n        head['Content-Type'] = 'application/json';\n        res.writeHead(target.code, head);\n        res.end(JSON.stringify({\n          error: target.code + ' ' + (http.STATUS_CODES[target.code] || 'Forbidden')\n        }));\n      } else {\n        head['Content-Type'] = 'text/plain';\n        res.writeHead(target.code, head);\n        res.end(target.code + ' ' + (http.STATUS_CODES[target.code] || 'Forbidden') );\n      }\n\n    },\n    entryParser: function(entry) {\n      var code;\n      entry = entry || 403;\n      if(typeof entry ==='string' || typeof entry === 'number') {\n        code = parseInt(entry) || 403;\n      }\n      else {\n        code = 403;\n      }\n      return {\n        code: code,\n        html: entry.htmlFile?loadHtmlFile(entry.htmlFile):undefined\n      };\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-http-master/node_modules/http-master/modules/middleware/router.js":"'use strict';\n\nvar DispatchTable = require('../../src/DispatchTable');\n\nvar defaultModule = 'proxy';\nvar entryRegexp = /^\\s*(?:(\\w+)\\s*(?:->|: )\\s*)?(.*)/;\n\nfunction handlerForMiddlewareList(middleware) {\n  return {\n    middleware: function(req, res, next) {\n      var length = middleware.length;\n\n      function runMiddleware(i) {\n        if (i < length) {\n          middleware[i].middleware(req, res, function(err) {\n            if (err) {\n              return next(err);\n            }\n            \n            runMiddleware(i+1);\n          }, middleware[i].dispatchTarget);\n        } else {\n          next();\n        }\n      }\n      runMiddleware(0);\n    },\n    moduleName: 'middlewareList',\n    entry: middleware\n  };\n}\n\nmodule.exports = function RouterMiddleware(di, portConfig, portNumber) {\n\n\n  function passEntryToModuleInstance(instance, entry) {\n    var dispatchTarget = entry;\n    if(instance.entryParser) {\n      // allow modules to cache arbitrary data per entry\n       dispatchTarget = instance.entryParser(entry);\n    }\n    return {\n      middleware: instance.requestHandler,\n      dispatchTarget: dispatchTarget\n    };\n  }\n\n  function passEntryToModule(moduleName, entry) {\n    var instance = di.resolve(moduleName + 'Middleware');\n    return passEntryToModuleInstance(instance, entry);\n  }\n\n  function parseSingleEntry(entry) {\n    var moduleName, entryKey;\n    \n    if(typeof entry === 'function') {\n      return passEntryToModuleInstance(di.resolve(entry), {});\n    }\n    let m = entry.toString().match(entryRegexp);\n    var moduleName = m[1] || defaultModule;\n    var entryKey = m[2];\n\n    return passEntryToModule(moduleName, entryKey);\n  }\n\n  function parseEntry(entry) {\n    if (typeof entry === 'object') {\n      if(entry instanceof Array) {\n        return handlerForMiddlewareList(entry.map(parseEntry));\n      }\n      else if(entry.$) {\n        return passEntryToModule(entry.$, entry);\n      }\n      else {\n        return passEntryToModule('router', entry);\n      }\n    }\n    return parseSingleEntry(entry);\n  }\n\n  return {\n    entryParser: function(routerEntries) {\n      if (!(routerEntries instanceof Array)) {\n        routerEntries = [routerEntries];\n      }\n      var middlewareList = routerEntries.map(function(routerEntry) {\n        if(typeof routerEntry !== 'object' && typeof routerEntry !== 'undefined') {\n          return parseSingleEntry(routerEntry);\n        }\n        var dispatchTable = new DispatchTable(portNumber, {\n          config: routerEntry,\n          entryParser: parseEntry,\n          requestHandler: function(req, res, next, target) {\n            target.middleware(req, res, next, target.dispatchTarget);\n          }\n        });\n        process.emit('dispatchTable', dispatchTable.table);\n        return {\n          middleware: DispatchTable.prototype.dispatchRequest.bind(dispatchTable)\n        }\n      });\n\n      return handlerForMiddlewareList(middlewareList);\n    },\n    requestHandler: function(req, res, next, target) {\n      target.middleware(req, res, next, target.dispatchTarget);\n    }\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-http-master/node_modules/http-master/modules/middleware/static.js":"var serveStatic = require('connect-gzip-static');\nvar send = require('send');\nvar path = require('path');\n\nmodule.exports = function StaticMiddleware() {\n  return {\n    requestHandler: function(req, res, next, target) {\n      target.middleware(req, res, function(err) {\n        if(err) return next(err);\n        var stream = send(req, path.join(target.entry, '404.html'), {});\n        stream.on('error', next);\n        stream.pipe(res);\n      });\n    },\n    entryParser: function(entry) {\n      return {middleware: serveStatic(entry), entry: entry};\n    }\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-http-master/node_modules/http-master/modules/middleware/websockify.js":"var regexpHelper = require('../../src/regexpHelper');\nvar net = require('net');\nvar url = require('url');\n\nmodule.exports = function WebsockifyMiddleware() {\n  return {\n    requestHandler: function(req, res, next, parsedEntry) {\n      if(req.upgrade) {\n        var socket = new net.Socket();\n\n        var target = parsedEntry.target;\n\n        if (req.match) {\n          target = regexpHelper(target, req.match);\n        }\n        if(target.match(/^(\\d+)$/)) {\n          target = 'localhost:' +  target;\n        }\n        var parsedTarget = url.parse('tcp://' + target);\n\n        socket.once('error', function(err) {\n          if(req.connection) {\n            req.connection.end();\n          }\n        });\n        socket.connect(parseInt(parsedTarget.port), parsedTarget.hostname || 'localhost',  function() {\n          websockifyService(req, socket);\n        });\n      }\n      next();\n    },\n    entryParser: function(entry) {\n      return {\n        target: entry\n      };\n    }\n  };\n};","/home/travis/build/npmtest/node-npmtest-http-master/node_modules/http-master/modules/services/comm.js":"'use strict';\nmodule.exports = function CommService(events, master, worker) {\n  let processListeners = [];\n  let Promise = require('bluebird');\n  let controller = master?master:worker;\n  let uuid = require('uuid');\n\n  if(master) {\n    return function(namespace) {\n      return {\n        send(name, data) {\n          master.workers.forEach(function(worker) {\n            worker.sendMessage(namespace + ':' + name, data);\n          });\n        },\n        onRequest(name, handler) {\n          events.on('msg:' + namespace + ':request:' + name, (reqData, worker) => {\n            Promise.resolve().then(() => handler(reqData.data, worker)).then(resData => {\n              worker.sendMessage(reqData.uuid, resData);;\n            }).catch(err => {\n              worker.sendMessage(reqData.uuid, {\n                error: err.message\n              })\n            });\n          });\n        },\n        on(name, cb) {\n          events.on('msg:' + namespace + ':' + name, cb);\n        }\n      }\n    };\n  } else if(worker) {\n    let requestMap = {};\n    \n    process.on('msg', msg => {\n      if(requestMap[msg.type]) {\n        if(msg.data && msg.data.error) {\n          requestMap[msg.type].error(msg.data.error);\n        } else {\n          requestMap[msg.type](msg.data);\n        }\n      }\n    });\n    \n    return function(namespace) {\n      let workerInterface = {\n        request(name, data, cb) {\n          return new Promise((resolve, reject) => {\n            let __uuid = uuid.v4();\n            requestMap[__uuid] = data => {\n              delete requestMap[__uuid];\n              resolve(data);\n            };\n            requestMap[__uuid].error = err => {\n              delete requestMap[__uuid];\n              if(!(err instanceof Error)) {\n                err = new Error(err);\n              }\n              reject(err);\n            };\n            \n            worker.sendMessage(namespace + ':request:' + name, {\n              data: data,\n              uuid: __uuid\n            });\n          }).timeout(10000).nodeify(cb);\n        },\n        send(name, data) {\n          worker.sendMessage(namespace + ':' + name, data);\n        },\n        on(name, cb) {\n          events.on('msg:' + namespace + ':' + name, cb);\n        }\n      };\n      \n      return workerInterface;\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-http-master/node_modules/http-master/modules/services/logFile.js":"var fs = require('fs');\nvar uidNumber = require('uid-number');\n\nmodule.exports = function LogFileService(config, commService, master, worker) {\n\n  var comm = commService('logFile');\n\n  var logFileHandlers = {};\n\n  var user = config.user;\n  var group = config.group;\n\n  if(master) {\n    var serviceFunction = function(logFile) {\n      if(logFileHandlers[logFile])\n        return logFileHandlers[logFile];\n\n      var watch;\n      var stream;\n\n      function openLogFile(logFile) {\n        if(logFile === 'stdout' || logFile === 'stderr') {\n          stream = process[logFile];\n          return stream;\n        }\n        stream = fs.createWriteStream(logFile, {\n          'flags': 'a'\n        });\n        if(user || group) {\n          uidNumber(user, group, function(err, userId, groupId) {\n            fs.chown(logFile, userId, groupId);\n          });\n        }\n        stream.once('open', function() {\n          watch = fs.watch(logFile, function(action, filename) {\n            if (action == 'rename') {\n              watch.close();\n              openLogFile(logFile);\n            }\n          });\n        });\n        return stream;\n      }\n      openLogFile(logFile);\n\n      comm.on('write:' + logFile, function(data) {\n        stream.write(data);\n      });\n\n      logFileHandlers[logFile] = {\n        write: function(data) {\n          stream.write(data);\n        }\n      };\n\n      return logFileHandlers[logFile];\n    };\n\n    comm.on('open', serviceFunction);\n\n    return serviceFunction;\n\n  } else {\n    return function(logFile) {\n      comm.send('open', logFile);\n      return {\n        write: function(data) {\n          comm.send('write:' + logFile, data);\n        }\n      }\n    };\n  }\n};\n"}